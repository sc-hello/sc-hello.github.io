@[TOC](目录)
# 1 基于Thrift的RPC框架的开发和维护
## 项目介绍
公司项目整体架构是基于分布式的：以Java集成各功能模块作为客户端，Python提供机器学习算法支持作为服务端，以RPC保证高效稳定通信。Thrift作为一种典型的CS结构，且支持跨语言，故以此进行RPC开发。在Thrift的技术选型上，使用TFramedTransport作为传输方式、TCompactProtocol作为传输协议（编码方式），TForkingServer作为服务模型；同时，为了保证服务的稳定性，客户端启用一个心跳机制来维护长连接，服务端建立一个管理进程监测维护各服务进程。

> 分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。

## RPC及实现RPC需要的技术
1. RPC（Remote Procedure Call Protocol，远程过程调用协议）：是一种通过网络从远程服务器上请求服务，而不需要了解底层网络技术的协议；RPC使得客户端在远程调用时，能够像本地调用一样方便，而感知不到远程调用的逻辑；
2. 关键技术包括：通信协议、序列化、接口描述、服务框架、性能和语言支持等；
3. RPC可以使用TCP作为传输协议，也可以使用HTTP（如gRPC），但一般都是TCP；
4. RPC = socket + 动态代理

> 动态代理发生在服务调用方，RPC 框架需要解决的是：像调用本地接口一样调用远程的接口。于是如何组装数据报文、如何经过网络传输发送至服务提供方，以及如何屏蔽远程接口调用的细节，便是动态代理需要做的工作。

![在这里插入图片描述](https://img-blog.csdnimg.cn/fe5e3dfd891647669f71b41ff41beb02.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

### 1 动态代理
1. 动态代理用于生成客户端存根、服务端存根，当调用 RPC 远程接口时，实际是调用了它的代理类，再由代理类使用 Socket 技术向远程接口发送请求信息;
2. 一般这个代理过程可以使用 JDK 提供的原生代理方式，也可以使用开源的 CGLib 代理;

![在这里插入图片描述](https://img-blog.csdnimg.cn/44074a28e246496a931a4c441e5e828e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)


一个完整的RPC架构包含5个核心组件，分别是：客户端、客户端存根、网络传输模块、服务端存根、服务端：
	
 - 客户端（Client）：服务调用方；
 - 客户端存根（Client Stub）：存放服务端的地址信息，将客户端的请求参数打包成网络消息，再通过网络传输发送给服务方；
 - 网络传输模块（Network Service）：底层传输，可以是TCP或HTTP；
 - 服务端存根（Server Stub）：接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。
 - 服务端（Server）：服务的真正提供者；
![在这里插入图片描述](https://img-blog.csdnimg.cn/684dad4207694f32af1949830a2a87ab.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

### 2 序列化和反序列化
1. 在网络信息传输中，所有数据都会被转换为字节码进行传送;
2. RPC在调用的过程中，需要把接口的入参和出参通过序列化转化成字节码和反序列化为对象，也就是编码和解码操作;
3. 比较常用的开源的序列化方式有JSON、Protobuf等，当然也可以用Java自带的序列化方式，但这个过程非常耗时，所以一般不会使用;
### 3 NIO通信组件
1. 在 RPC 通信实现方案中，需要考虑并发性能问题，非常重要的一环是需要考虑I/O的选择。传统阻塞式的IO显然是不合适的，因此需要非阻塞IO，即NIO;
2. 但实现NIO通信比较复杂，也容易出错，所以在RPC通信中一般都会选择Netty作为NIO的通信组件;
### 4 注册中心
1. 在 NIO 的通信中，接口提供方需要把接口注册到一个中心，在接口调用方调用服务时，需要从注册中心获取接口的提供方，其中最核心的信息就是IP+端口号;
2. 拿到提供方信息后进行 Socket 连接操作，接下来就可以通信了;
3. 注册中心通常会选择ZooKeeper，但也可以使用其他方式，如Redis;
4. 注册中心可以缺失，如果接口调用方知道接口提供方的IP+端口号，就可以直接调用，而不需要向注册中心去查询。直接调用的优点就是直接且易于维护，缺点则是不够灵活，如果服务的地址改变了，我们需要手动修改服务提供的地址，而不能动态地实时地去获取；

## 为什么使用RPC
RPC要解决的两个问题：

1. 解决分布式系统中，服务之间的调用问题。

2. 远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。

### RPC和HTTP
![在这里插入图片描述](https://img-blog.csdnimg.cn/33cc5ad3b6d44e46983bd65e9b8fd678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)


1. HTTP是RPC的一种；
2. HTTP是在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段，接口可能返回一个JSON字符串或XML文档，然后客户端再去处理这个返回的信息。优点就是简单直接、开发方便；
3. 如果一个系统内部子系统较多、接口非常多，RPC框架的优势就显示出来了：1 RPC用到了动态代理模式，能解耦服务；2 RPC调用是面向服务的封装，针对服务的可用性和效率等都做了优化（传输方式、传输协议、服务模型等），单纯使用HTTP调用则缺少了这些特性；3 RPC框架一般都有注册中心，有丰富的监控管理、发布和下线接口等；4 长连接：不必每次通信都要像HTTP一样去3次握手，减少了网络开销；

## Thrift简介
1. Thrift是用于实现RPC通信的一种框架，支持跨语言，包括C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, OCaml, Delphi等；
2. Thrift是一种典型的CS（客户端/服务端）结构，客户端和服务端可以使用不同的语言开发。既然客户端和服务端能使用不同的语言开发，就一定要有一种中间语言来关联客户端和服务端的语言，这种语言就是IDL（Interface Description Language）；

## Thrift整体架构
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210617090640496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)
1. 业务逻辑层是用户实现的业务逻辑；
2. 代码框架层是根据Thrift定义的服务接口描述文件生成的客户端和服务器端代码框架；
3. 数据读写操作层是根据Thrift文件生成代码实现数据的读写操作；
4. 以下是Thrift的传输协议、传输方式以及底层的IO通信，使用thrift可以很方便的定义一个服务并且选择不同的传输协议和传输方式；

## Thrift 三大重要组件：Transport、Protocol和 Server
### 传输方式Transport
1. TSocket：阻塞型socket，用于客户端，采用系统函数read和write进行读写数据；
2. TNonblockingServerSocket：非阻塞型socket，用于服务端，accept到的socket类型都是TSocket；
3. TBufferedTransport和TFramedTransport：非阻塞有缓存，均继承TBufferBase，调用下一层TTransport类进行读写操作，结构非常相似。但TFramedTransport以帧为传输单位，帧结构为：4字节+传输字符串，4字节用来存储传输字符串的长度，该字符串才是真正需要传输的数据，因此TFramedTransport每传一帧都要比TBufferedTransport和TSocket多传4字节；
4. TFileTransport：以文件形式进行传输；

### 传输协议Protocol（编码方式）
Thrift传输协议总体上可划分为二进制（binary）和文本（text）传输协议两大类，一般在生产环境中使用二进制类型的传输协议（相比于文本和JSON传输效率更高）。

1. TBinaryProtocol：使用二进制编码格式进行数据传输，Thrift的默认协议；
2. TCompactProtocol：压缩的二进制编码格式，使用高效率的、密集的二进制编码格式进行数据传输；
3. TJSONProtocol：使用JSON数据编码格式进行数据传输，在网络中以文本方式传输，易于抓包分析和理解；
4. TDebugProtocol：使用text编码格式进行数据传输，可读性强，常用于编码人员测试；

#### 二进制协议 VS 文本协议
1. **二进制协议**：没有冗余字段、传输高效、方便解析（固定长度，并且可以直接比较字节），缺点就是定义的比较死，哪个位置有哪些东西，是什么意义都是定义死的，场景单一；
2. **文本协议**：直观、描述性强、容易理解、便于调试，缺点就是冗余数据较多，不适宜传输二进制文件（比如：图片等），解析复杂（需要进行字符串比较）；
3. **应用场景**：1 高效传输和数据安全，使用二进制协议；2 便于调试和命令较少（如即时通讯软件），使用文本协议；

### 服务模型Server（Java）
#### 1 TSimpleServer模式
![在这里插入图片描述](https://img-blog.csdnimg.cn/53468a4d64e24368aa6b6c463b0cb451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)
1. TSimpleServer的工作模式下只有一个工作线程，循环监听新请求的到来并完成对请求的处理，它只是在简单的演示时候使用；
2. TSimpleServer的工作模式采用最简单的阻塞IO，实现方法简洁明了，便于理解，但是一次只能接收和处理一个socket连接，效率比较低，主要用于演示Thrift的工作过程，在实际开发过程中很少用到它。

#### 2 TNonblockingServer模式
![在这里插入图片描述](https://img-blog.csdnimg.cn/5ccf3b9a3769451e841aeecd692ccb3c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)
TNonblockingServer也是单线程工作，但是该模式采用NIO的方式，所有的socket都被注册到selector中，在一个线程中通过selector循环监听所有的socket；每次selector结束时，处理所有的处于就绪状态的socket：对于监听到的socket产生一个新业务socket并将其注册到selector中，对于有数据到来的socket进行数据读取操作，对于有数据发送的socket进行数据发送操作。

**TNonblockingServer模式优点**：

相比于TSimpleServer效率提升主要体现在IO多路复用上，TNonblockingServer采用非阻塞IO，同时监控多个socket的状态变化。

**TNonblockingServer模式缺点**：

TNonblockingServer模式在业务处理上还是采用单线程顺序来完成，在业务处理比较复杂、耗时的时候，例如某些接口函数需要读取数据库执行时间较长，此时该模式效率也不高，因为多个调用请求任务依然是一个接一个顺序执行。

#### 3 THsHaServer模式（半同步半异步）
![在这里插入图片描述](https://img-blog.csdnimg.cn/0ace768a12654ba789110e8116512d53.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)
THsHaServer类是TNonblockingServer类的子类，TNonblockingServer模式中，采用一个线程来完成对所有socket的监听和业务处理，造成了效率的低下，THsHaServer模式的引入则是部分解决了这些问题。THsHaServer模式中，引入一个线程池来专门进行业务处理。

**THsHaServer的优点**：

与TNonblockingServer模式相比，THsHaServer在完成数据读取之后，将业务处理过程交由一个线程池来完成，主线程直接返回进行下一次循环操作，效率大大提升。

**THsHaServer的缺点**：

主线程需要完成对所有socket的监听以及数据读写的工作，当并发请求数较多，且发送数据量较大时，监听socket上新连接请求不能被及时接收。

#### 4 TThreadPoolServer模式
![在这里插入图片描述](https://img-blog.csdnimg.cn/1043f413bdb04583a1bbaa1d83f15fcf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)
TThreadPoolServer模式采用阻塞socket方式工作，主线程负责阻塞式监听是否有新socket到来，业务处理交由一个线程池来处理。

**TThreadPoolServer模式优点**：

线程池模式中，数据读取和业务处理都交由线程池完成，主线程只负责监听新连接，因此在并发量较大时新连接也能够被及时接收。线程池模式比较适合服务器端能预知最多有多少个客户端并发的情况，这时每个请求都能被业务线程池及时处理，性能也非常高。

**TThreadPoolServer模式缺点**：

线程池模式的处理能力受限于线程池的工作能力，当并发请求数大于线程池中的线程数时，新请求也只能排队等待。

#### 5 TThreadedSelectorServer模式
![在这里插入图片描述](https://img-blog.csdnimg.cn/9d3939284d214de3b0db6e061f3b6c7f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)
TThreadedSelectorServer模式是目前Thrift提供的最高级的模式，它内部有如下几个部分构成：

1. 一个AcceptThread线程对象，专门用于处理监听socket上的新连接；
2. 若干个SelectorThread线程对象专门用于处理业务socket的网络I/O操作，所有网络数据的读写均是由这些线程来完成；
3. 一个负载均衡器SelectorThreadLoadBalancer对象，主要用于AcceptThread线程接收到一个新socket连接请求时，决定将这个新连接请求分配给哪个SelectorThread线程；
4. 一个ExecutorService类型的工作线程池，在SelectorThread线程中，监听到业务socket中有调用请求过来，则将请求读取之后，交给ExecutorService线程池中的线程完成此次调用的具体执行；

TThreadedSelectorServer模式中有一个专门的线程AcceptThread用于处理新连接请求，因此能够及时响应大量并发连接请求；另外它将网络I/O操作分散到多个SelectorThread线程中来完成，因此能够快速对网络I/O进行读写操作，能够很好地应对网络I/O较多的情况；TThreadedSelectorServer对于大部分应用场景性能都不会差，因此，如果实在不知道选择哪种工作模式，使用TThreadedSelectorServer就可以。


链接: [Python服务端源码解析](https://zhuanlan.zhihu.com/p/264348658).

### 服务模型Server（Python）
#### 1 TSimpleServer
TSimpleServer的工作模式采用最简单的阻塞IO，实现方法简洁明了，便于理解，但是一次只能接收和处理一个socket连接，效率比较低。
![在这里插入图片描述](https://img-blog.csdnimg.cn/a16827291b034d94b2e8166db8d839e2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)
**源码分析**

![在这里插入图片描述](https://img-blog.csdnimg.cn/77e2a62a6b104c70b97f9e107215d390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

1. 设置TServerSocket的listen()方法启动连接监听；
2. 以阻塞的方式接受客户端的连接请求，每进入一个连接即为其创建一个TSocket对象（封装socket连接）；
3. 为客户端创建输入传输通道对象、输出传输通道对象、输入协议对象和输出协议对象；
4. processor对象为服务模型创建之前创建的，用来处理具体的业务请求；

#### 2 TThreadPoolServer
服务启动时先创建好self.threads个线程，每个线程负责从队列clients中获取客户端连接TSocket对象。而主线程负责accept客户端的连接并创建TSocket对象，放入clients队列。

![在这里插入图片描述](https://img-blog.csdnimg.cn/4406c1ec4b9c4224a695ecdf2ef4e7e0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/2f474284fe0047b88bc1e908b1ee160c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

**3 TNonblockingServer**
类似于java版thrift中的THsHaServer，思路是服务启动时创建threads个线程负责处理task队列中的任务消息。而主线程利用io多路复用技术将准备好的可读消息放入task队列供业务线程处理，同时在处理结束后可写时直接将结果返回给客户端。

![在这里插入图片描述](https://img-blog.csdnimg.cn/a1335e1e4c6242dd84de7baa1643feb5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/79c77c2784374d69880d6e966833ff88.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/17345db8e0e54d5ab9de62e436e5b48c.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/a7781840c5f24113b0c765e10d298678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

**4 TForkingServer VS TProcessPoolServer**

1. 由于Python的GIL锁，所以Python没有真正的多线程，无法实现并行运作，多任务场景下效率低下，因此引入了两个多进程模型；
2. 其中TForkingServer，服务端每次监听到client请求，会os.fork一个子进程进行业务处理；

![在这里插入图片描述](https://img-blog.csdnimg.cn/437f212c38744371a7d08343c99fc12d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

3. TProcessPoolServer服务启动时创建指定个数的进程；

![在这里插入图片描述](https://img-blog.csdnimg.cn/bbeb1e832c594c8894a9a6679ff91c17.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/f3b0872d438743fd921ca74c58c0aaa2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

# 2 基于Spring Boot的个人博客系统
## 1 系统功能框架图
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210716095631204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)


# 3 基于Servlet和JSP的网上书城
## 1 什么是Servlet
Servlet是一个Java类，是在服务器上运行以处理客户端请求并作出响应的程序。

## 2 Tomcat容器等级
Tomcat容器分四个等级，Servlet容器管理Context容器，一个Context对应一个Web工程。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717141308370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)
## 3 手工编写一个Servlet
1. 继承HttpServlet；
2. 重写doGet()或doPost()方法；
3. 在web.xml中注册Servlet；
4. 部署运行；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717142148330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)
## 4 测试题
假设在helloapp应用中有一个HelloServlet类，它在 web.xml文件中的配置如下:

```java
 <servlet>   
  <servlet-name>HelloServlet</servlet-name>    
  <servlet-class>org.javathinker.HelloServlet</servlet-class>
 </servlet>  
<servlet-mapping>   
  <servlet-name>HelloServlet</servlet-name>  
  <url-pattern>/hello</url-pattern>
</servlet-mapping>  
```

那么在浏览器端访问HelloServlet的URL是什么?

 - 答：http://localhost:8080/helloapp/hello
 - 解析：localhost是服务器主机名，也可以是IP地址127.0.0.1；8080是tomcat服务器的端口号；helloapp是web工程的上下文地址ContextRoot（一般情况下与web工程名一致）；最后是\<url-pattern/>标签中的内容。

## 5 Servlet执行流程
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717154602760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

## 6 Servlet生命周期
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717155659793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

1. 初始化阶段：调用构造方法创建Servlet实例，然后调用init()方法，在整个生命周期内，init()只被调用一次；
2. 响应客户端请求阶段：调用service()方法。由service()方法根据提交方式选择执行doGet()或者doPost()方法；
3. 终止阶段：服务器关闭时，调用destroy()方法。在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收；

**架构图**

下图显示了一个典型的 Servlet 生命周期方案。

1. 第一个到达服务器的 HTTP 请求被委派到 Servlet 容器；
2. Servlet 容器在调用 service() 方法之前加载 Servlet；
3. 然后 Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 service() 方法；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717163815327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)


## 7 Tomcat装载Servlet的三种情况
1. Servlet容器启动时自动装载某些Servlet，实现它只需要在web.xml中的`<Servlet></Servlet>`之间添加如下代码：`<loadon-startup>1</loadon-startup>`，数字越小优先级越高；
2. Servlet容器启动后，客户端首次向Servlet发送请求；
3. Servlet类文件被更新后，会自动重新装载Servlet；



