@[TOC](目录)
# Redis简介
1. Redis是一个速度非常快的非关系型/NoSQL数据库，它不使用表，也不会预定义或强制要求用户对Redis存储的不同数据进行关联；
2. Redis为什么速度非常快：1 纯内存操作，数据存在内存中；2 数据结构简单；3 单线程：不存在多进程或者多线程导致的切换而消耗CPU资源，也不用去考虑各种锁的问题；

# 为什么要用Redis/为什么要用缓存？
0. 主要从”高性能“和”高并发“这两点来看；
1. **高性能**：1 如果用户是第一次访问数据库中的某些数据，过程将比较慢，因为是从硬盘上读取的；2 然后将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了；3 操作缓存就是直接操作内存，所以速度非常快；4 如果数据库中的对应数据改变，同步改变缓存中相应的数据即可；
2. **高并发**：1 直接操作缓存能够承受的请求远远大于直接访问数据库；2 因此考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存而不用经过数据库；

# 为什么要用Redis而不用map/guava做缓存？
1. 缓存分本地缓存和分布式缓存。以Java为例，使用自带的Map或guava实现的是本地缓存，轻量快速，生命周期随JVM的销毁而结束，在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性；
2. Redis或memcached之类的称为分布式缓存，在多实例情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持Redis或memcached服务的高可用，整个程序架构比较复杂；

# Redis的线程模型
1. Redis内部使用文件事件处理器file event handler，这个文件事件处理器是单线程的，因此Redis是单线程模型。它采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理；
2. 文件事件处理器的结构包含4个部分：多个socket、IO多路复用程序、文件事件分派器、事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）；
3. 多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，会将socket产生的事件放入队列中排队。事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理；

# Redis数据结构
1. Redis存储键（key)和5种不同类型的值（value)之间的映射；
2. 这5种类型分别是：STRING（字符串）、HASH（散列表）、LIST（列表）、SET（集合）、ZSET（有序集合）；

# Redis与Memcached的异同
0. 两者都是非关系型内存键值数据库，主要有以下不同：
1. **数据类型**：1 Redis支持5种不同的数据类型，可以更灵活地解决问题；2 Memcached仅支持字符串类型；
2. **数据持久化**：1 Redis支持两种持久化策略：RDB快照和AOF日志；2 Memcached不支持持久化；
3. **分布式**：1 Redis Cluster实现了分布式的支持；2 Memcached不支持分布式；
4. **内存管理机制**：在Redis中，并不是所有数据都一直存储在内存中，可以将一些很久没用的数据交换到磁盘，而Memcached的数据则会一直在内存中；
5. **线程模型**：1 Redis使用单线程的多路IO复用模型；2 Memcached是多线程非阻塞IO复用模型；

# redis 设置过期时间
1. redis中有个设置时间过期的功能，即对存储在 redis 数据库中的数据可以设置⼀个过期时间。作为⼀个缓存数据库，这是非常实用的；
2. 假设设置了⼀批 key 只能存活1个小时，那么1小时后，redis将对这批key执行**定期删除+惰性删除**操作；
3. **定期删除**：redis默认是每隔 100ms 就随机抽取⼀些设置了过期时间的key，检查其是否过期，如果过期就删除（考虑性能）；
4. **惰性删除** ：数据到达过期时间，不做处理。等下次访问该数据时，如果未过期，返回数据 ；如果发现已过期，删除，返回不存在；
5. 仅仅通过设置过期时间还是有问题的。设想：如果定期删除漏掉了很多过期 key，然后你也没及时去查，即没走惰性删除，将造成大量过期key堆积在内存里，导致redis内存块耗尽。这就需要redis 内存淘汰机制来解决这个问题了；

#  redis 内存淘汰机制(MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?)
redis提供了8种数据淘汰策略：

1. volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰；
2. volatile-lfu：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰；
3. volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰；
4. volatile-random：从已设置过期时间的数据集中任意选择数据淘汰；
5. allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（最常用的淘汰机制）；
6. allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key；
7. allkeys-random：内存不足以容纳新写入数据时，从数据集中随机选择key淘汰；
8. no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错；

# redis 持久化机制(怎么保证 redis 挂掉重启后数据可以进行恢复)

 1. 很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，主要是为了以后重用数据（比如重启机器、系统故障之后恢复数据）；
 2. redis的⼀种持久化方式叫快照（RDB），另⼀种方式是只追加文件（AOF）；
 3. **快照持久化（RDB）**：Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，比如可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用；

快照持久化是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：

```java
save 900 1 #在900秒(15分钟)之后，如果⾄少有1个key发⽣变化，Redis就会⾃动触发BGSAVE命令创建快照。

save 300 10 #在300秒(5分钟)之后，如果⾄少有10个key发⽣变化，Redis就会⾃动触发BGSAVE命令创建快照。

save 60 10000 #在60秒(1分钟)之后，如果⾄少有10000个key发⽣变化，Redis就会⾃动触发BGSAVE命令创建快照。
```

 4. **只追加文件持久化（AOF）**：与快照持久化相比，AOF持久化的实时性更好，因此已成为主流的持久化方案。开启AOF持久化后每执行⼀条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。

在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：

```java
appendfsync always #每次有数据修改发生时都会写入AOF文件，这样会严重降低Redis的速度

appendfsync everysec #每秒钟同步⼀次，显式地将多个写命令同步到硬盘

appendfsync no #让操作系统决定何时进行同步
```

为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步⼀次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。

# redis 事务
1. redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能；
2. 事务提供了一种将多个命令请求打包，然后⼀次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求；
3. 在redis中，事务总是具有原子性、⼀致性和隔离性，并且当 redis 运行在某种特定的持久化模式下时，事务也具有持久性；
4. redis同⼀个事务中如果有⼀条命令执行失败，其后的命令仍然会被执行，没有回滚；

# 缓存雪崩和缓存穿透问题解决方案
## 缓存雪崩
 - **概念**：缓存同⼀时间大面积的失效，导致后面的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。
 - **有哪些解决办法？**
	1. 事前：1 尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上；2 选择合适的内存淘汰机制；
	2. 事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉（1 用户发送一个请求 2 收到请求，先查本地ehcache缓存，如果没有再查redis 3 如果ehcache和redis都没有，就查数据库 4 将数据库中的结果，写入ehcache和redis 5 限流：假设限制每秒就2000个请求，一秒过来5000个请求，此时只有2000个请求会通过限流组件，进入数据库 6 剩余的3000个请求走降级，调用自己开发好的一个降级的组件，返回一些默认的值，比如友情提示，或空值）；
	3. 事后：利用 redis 持久化机制尽快恢复缓存集群，一旦重启，自动从磁盘上加载数据恢复内存中的数据；

## 缓存穿透
 - **概念**：缓存穿透就是大量请求的 key 不存在于缓存中，导致请求直接落到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库，⼀般 3000 个并发请求就能打死大部分数据库了。
 - **有哪些解决办法？**
	1. **做好参数校验**：⼀些不合法的参数请求直接抛出异常信息返回给客户端，比如查询的数据库 id 不能小于0等；
	2. **缓存无效 key** : 如果缓存和数据库都查不到某个 key 的数据就写⼀个到 redis 中去并设置过期时间。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求key，会导致 redis 中缓存大量无效的 key，因此这种方案并不能从根本上解决此问题；
	3. **布隆过滤器**：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程；

#  如何解决 Redis 的并发竞争 Key 问题
Redis 的并发竞争 Key 的问题也就是多个系统同时对⼀个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！

**解决方案**：使用基于zookeeper临时有序节点实现的分布式锁。大致思想为：1 每个客户端对某个方法加锁时，会在zookeeper上的与该方法对应的指定节点的目录下，生成⼀个唯一的瞬时有序节点。2 判断是否获取锁只需要判断该节点是否是有序节点中序号最小的⼀个。3 当释放锁的时候，只需将这个瞬时节点删除即可；

# 如何保证缓存与数据库双写时的数据一致性？
一般来说，如果允许缓存可以偶尔跟数据库有不一致的情况，也就是说系统不是严格要求 “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：读请求和写请求串行化，串到一个内存队列里去。串行化之后，就会导致系统的吞吐量大幅度降低。

Cache Aside Pattern: 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。更新的时候，先删除缓存，然后更新数据库。




