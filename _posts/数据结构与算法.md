@[TOC](目录)
# 1 Prim算法（求最小生成树）+1

 1. 将最小生成树中的顶点作为一个集合，非最小生成树中的顶点作为另外一个集合，利用索引最小优先队列存储所有的横切边；
 2. 随意选取起点，加入到最小生成树中（标记该顶点），同时初始化索引最小优先队列(遍历起点的邻接表，添加到索引最小优先队列中)；
 3. 调用索引最小优先队列的delMin()，将最小横切边对应的顶点加入最小生成树的集合中（标记该顶点），同时遍历该顶点的邻接表，新增或更新横切边（更新索引最小优先队列）；
 4. 重复3，直到索引最小优先队列为空；

# 2 Kruskal算法（求最小生成树）+1
1. 使用最小优先队列PriorityQueue存储所有边，每次使用.delMin()取出权重最小的边，并得到该边关联的两个顶点v和w；
2. 通过并查集判断v和w是否已经连通，如果连通，则证明这两个顶点在同一棵树中，那么就不能把这条边添加到最小生成树中，因为在最小生成树的任意两个顶点上添加一条边，都会形成环，而最小生成树不能有环的存在；如果不连通，则通过并查集把顶点v所在的树和顶点w所在的树合并成一棵树，并把这条边加入到一个队列中；
3. 直到队列中含有V-1条边（图中共V个顶点），最终队列中存储的就是最小生成树的所有边；

# 3 Dijstra算法（求最短路径）+1

1. edgeTo存储起点到当前顶点的最短路径的最后一条边，distTo存储起点到当前顶点的最短路径的总权重；
2. 给定图G和起点s，初始化s到s的最短路径的总权重distTo[s]=0，起点s到其他顶点的总权重为无穷大；
3. 借助索引最小优先队列使用松弛技术处理图的各个顶点，更新edgeTo和distTo，最终就得到了最短路径树；


# 4 拓扑排序+1

1. 拓扑排序：给定一幅有向图，将所有的顶点排序，使得所有有向边均从排在前面的顶点指向排在后面的顶点，这样就可以明确地表示出每个顶点的优先级；
2. 实现：基于一幅图，先检测有没有环；如果没有环，再调用顶点排序；
3. 检测是否有环：对每个顶点调用深度优先搜索，如果当前顶点正在搜索，则把对应的onStack数组中的值改为true，标识进栈；如果当前顶点搜索完毕，则把对应的onStack数组中的值改为false，标识出栈；如果即将要搜索某个顶点，但该顶点已经在栈中，则图中有环；
4. 顶点排序：添加一个栈用来存储顶点，当进行深度优先搜索时，每搜索完毕一个顶点，就把该顶点放入到栈中，如此就实现了顶点排序；

