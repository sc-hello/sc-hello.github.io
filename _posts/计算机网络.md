@[TOC](目录)
# 基础
## 五层协议
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210518192458875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)
1. **应用层** ：1 直接为用户的应用进程提供数据传输服务；2 应用层协议有HTTP、DNS等；3 数据单位为报文；
2. **传输层** ：1 为两个主机中的进程提供通用的数据传输服务；2 由于一个主机可同时运行多个进程，因此传输层有复用和分用的功能：复用，就是多个应用层进程可同时使用下面传输层的服务；分用，就是把收到的信息分别交付给上面应用层中相应的进程；3 传输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力交付的数据传输服务，数据单位为用户数据报；
3. **网络层** ：1 为分组交换网上的不同主机提供数据传输服务；2 网络层把运输层传递下来的报文段或者用户数据报封装成分组；3 选中合适的路由，使源主机的分组能够通过网络中的路由器找到目标主机；4 网络层协议有IP（网际协议）、ARP（地址解析协议）、RARP（逆地址解析协议）等；5 数据单位为分组；
4. **数据链路层** ：1 网络层针对的是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务；2 数据链路层把网络层传下来的分组封装成帧；3 数据链路层地址为MAC地址；4  数据单位为帧；
5. **物理层** ：1 主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等；2 数据单位为比特；

## OSI七层协议
相比于五层模型，OSI七层协议多出了表示层和会话层：

 - **表示层** ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题；
 - **会话层** ：建立及管理会话；

五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。

## TCP/IP四层协议
1. 只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层；
2. TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210518193547752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

3. TCP/IP 协议族是一种沙漏形状，中间小两头大，IP 协议在其中占据举足轻重的地位；
![4.](https://img-blog.csdnimg.cn/20210518193628771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

## IP（网络层）和MAC（数据链路层）之间的区别和联系
1. IP的作用是实现主机之间通信，MAC的作用是实现直连的两个设备之间通信；
2. 举例：1 小明去一个很远的地方旅游，要转好多次火车，于是制定了一个行程表，行程表标识了行车路线，小明购买了火车票，每一张火车票只在限定区间有效；2 行程表就相当于网络层，行程开始好比源IP，行程终点好比目的IP；每个火车区间就相当于数据链路层，区间出发点好比源MAC地址，区间目标点好比目的MAC地址；3 源IP地址和目标IP地址在传输过程中是不会变化的，而源 MAC 地址和目标MAC地址⼀直在变化；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210705171549122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)
## 网络中两台主机通信完整过程
### 1 主机A和主机B在同一个二层网络中，直接走二层交换
![在这里插入图片描述](https://img-blog.csdnimg.cn/bbe0f15d535040f3a4e278db4f070fdd.png)
1. 1 主机A查看自己的ARP缓存，检查是否有主机B的IP到MAC的映射，如果有映射，构造报文，目的IP为主机B的IP，源IP为主机A的IP，目的MAC为主机B的MAC，源MAC为主机A的MAC，将报文发送给交换机C，交换机C进行MAC地址表学习，将主机A的MAC和报文入端口号记录下来；2 然后交换机C查看自己的MAC转发表，检查是否有主机B的MAC到端口的映射，如果有映射，获取对应的端口，将报文从此端口转发出去，报文到达主机B；3 如果交换机C没有主机B的MAC转发表映射，则采用洪泛的形式广播报文，主机B收到报文后向主机A回复，交换机C进行MAC表学习，将主机B的MAC和报文入端口号记录下来；

2. 1 如果主机A的ARP缓存中没有主机B的IP到MAC的映射，主机A需要先发送ARP请求，以获取主机B的MAC； 2 A将报文发往交换机C，交换机C采用洪泛的形式广播报文，主机B收到广播报文后，在自己的ARP缓存表中写入主机A的IP到MAC的映射，将自己的MAC封装到ARP回复报文中，单播给主机A，主机A获取到主机B的MAC后，在自己的ARP缓存表中写入主机B的IP到MAC的映射，构造报文发送给主机B，过程同上；

3. 主机B向主机A回复报文的过程类似；

### 2 主机A和主机B不在同一个网络中，走三层路由
![在这里插入图片描述](https://img-blog.csdnimg.cn/57da807b51f547fdbbb090b69a6e201e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)
1. 主机A查看自己的ARP缓存表，检查是否有路由器E的IP到MAC的映射，如果有映射，获取路由器E的MAC，构造报文，目的IP为主机B的IP，源IP为主机A的IP，目的MAC为路由器E的MAC，源MAC为主机A的MAC，将报文通过交换机C发往路由器E，过程同上。 如果主机A没有路由器E的IP到MAC的映射，需要发送ARP请求，获取路由器E的MAC，过程同上；2. 路由器E收到主机A的报文后，剥离报文的MAC帧头，查询路由表，发现目标主机B所在的网络是直连的，查看自己的ARP缓存表，如果有主机B的IP到MAC的映射，获取主机B的MAC，封装报文MAC帧头，目的MAC为主机B的MAC，源MAC为路由器E的MAC，将报文通过交换机D发往主机B，如果路由器E没有主机B的IP到MAC的映射关系，需要发送ARP请求，获取主机B的MAC，过程同上；
2. 主机B向主机A回复报文的过程类似；

## 路由器是如何转发分组的
![在这里插入图片描述](https://img-blog.csdnimg.cn/13d80e2af48a4c7f855e9fa8ae2177ca.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

1. 提取IP分组首部中的目的IP地址D，得出其所在的网络N；
2. 判断目的IP地址所在的网络N是否与本路由器直接相连。如果是，直接交付给N，如果不是执行3；
3. 检查路由表中是否有目的IP地址的特定主机路由（对特定的目的主机指明的一个路由），如果有，按特定主机路由转发，如果没有，执行4；
4. 检查路由表中是否有到达网络N的路由，如果有，按指明的路由转发，如果没有，执行5；
5. 检查路由表中是否有默认路由，如果有按默认路由转发，如果没有，执行6；
6. 报告转发分组出错；
# TCP
## 三次握手
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210517203252163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)
 1. 第 1 次握手：客户端发送 SYN 包（seq=x）到服务端，此时客户端进入SYN-SENT状态，等待服务端确认；
 2. 第 2 次握手：服务器收到客户端的 SYN 包，向客户端发送确认包 ACK（ack=x+1)，同时自己发送一个 SYN 包（seq=y），即 ACK+SYN 包，此时服务端进入 SYN-RCVD状态；
 3. 第 3 次握手：客户端收到服务端的 ACK+SYN 包，向服务端发送确认包 ACK（ack=y+1），此包发送并接收完毕，双方进入ESTABLISHED状态。完成了 3 次握手；

SYN:同步序列编号

## 三次握手的原因
**原因 1**

1. 为了初始化序列号；
2. 通信双方需要通知对方建立连接以后的序列号的初始值（即上面的 x 和 y），作为以后数据传输的序号，保证应用层接收到的数据不会因为网络传输问题而乱序；
3. 进行第 3 次握手，就是告知服务端，客户端已收到服务端发送的序列号的初始值了；

**原因 2**

 1. A 向 B 发出连接请求，请求在某个节点滞留一段时间；
 2. A 发送超时，认为报文丢失，重传。这一次 B 马上收到，然后与 A 建立连接。数据传输完毕后，断开连接；
 3. 此时，滞留的请求到达了 B，B 又认为 A 发来请求；
 4. "两次握手"：B 认为传输连接又建立，并一直等待 A 传输数据，而此时 A 并无连接请求，因此不予理睬，这造成了 B 资源的浪费；
 5. "三次握手"：B 向 A 发送确认报文，由于是一个失效请求，A 不予理睬，建立连接失败；

## 四次挥手+1

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210419173344607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

 1. 第 1 次挥手：客户端发送FIN连接释放报文段（FIN=1，seq=u)，并停止发送数据，客户端进入 FIN-WAIT-1状态；
 2. 第 2 次挥手：服务端收到 FIN 后，发送ACK(ack=u+1) 给客户端 ，服务端进入CLOSE_WAIT状态，客户端收到后进入FIN-WAIT-2状态；
 3. 第 3 次挥手：服务端发送FIN连接释放报文段（FIN=1，seq=w)，并停止发送数据，服务端进入LAST-ACK状态；
 4. 第 4 次挥手：客户端收到 FIN 后，发送ACK(ack=w+1) 给服务端，客户端进入TIME-WAIT 状态，等待2MSL，接着客户端进入CLOSED状态，服务端收到后也进入CLOSED状态，完成 4 次挥手；

## 为什么需要TIME-WAIT状态+1
1. TIME-WAIT=2MSL，MSL即报文最大生存时间，主动发起关闭连接的一方，才会有TIME-WAIT状态；
2. 原因1：防止旧的数据包被收到。如果没有TIME-WAIT或者TIME-WAIT时间过短，如果有一个服务端在关闭连接之前发送的报文被网络延迟了，这时有相同端口的TCP连接被复用后，被延迟的报文抵达了客户端，那么客户端很有可能正常接收这过期的报文，就会造成数据错乱等严重问题。而经过2MSL 这个时间，足以让原来连接的数据包在网络中自然消失，再出现的数据包一定都是新建立连接所产生的；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210705112903398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

3. 原因2：等待⾜够的时间以确保最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正常关闭。如果客户端四次挥手的最后一个ACK报文在网络中丢失了，如果没有TIME-WAIT或者TIME-WAIT时间过短，客户端进入CLOSED状态，那么服务端会一直处在LAST-ACK状态，客户端将无法建立新的连接。而有了TIME-WAIT，如果服务端没有收到最后一个ACK报文，则会重发FIN关闭连接报文并等待新的ACK报文；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210705113541218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

4. 因此，客户端在TIME-WAIT状态等待2MSL后，就可以保证双方的连接正常关闭；


## 四次挥手的原因
1. 因为 TCP 连接是全双工通信，发送方和接收方都需要 FIN 报文和 ACK 报文，其中一方关闭是被动的；
2. 客户端发送 FIN 连接释放报文之后，服务器收到了这个报文，进入CLOSE-WAIT 状态，这个状态是为了让服务端发送尚未发送完毕的数据，发送完毕之后，服务端会发送 FIN 连接释放报文；

## TCP和UDP
1. **TCP**：1 传输控制协议，是面向连接的通信协议；2 在数据传输时，发送端和接收端要建立逻辑连接，每次连接的创建都要经过三次握手，每次连接的释放都要经过四次挥手，提供了可靠无差错的数据传输；3 下载文件浏览网页等;
2. **UDP**：1 用户数据报协议，是无连接的通信协议；2 在数据传输时，发送端和接收端不建立逻辑连接，发送端不会确认接收端是否存在就会发送数据，接收端在收到数据后也不会向发送端反馈是否收到，不能保证数据完整性； 3 在传输重要数据时不建议，但通信效率高可用于音视频会议，丢失一两个数据包没大影响;

## TCP协议如何保证可靠传输
1. 数据被**分割**成TCP认为最适合发送的数据包；
2. 给发送的每个包进行**编号**，接收方对数据包进行排序；
3. **校验和**：1 TCP将保持它首部和数据的检验和；2 这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化；3 如果收到报文段的检验和有差错，TCP将丢弃这个报文段以及不确认收到此报文段；
4. **接收端会丢弃重复的数据**；
5. **流量控制**：1 TCP连接的每一端都有固定大小的缓冲空间，TCP接收端只允许发送端发送接收端缓冲区能接纳的数据；2 当接收方来不及处理发送方的数据时，将告知发送方降低发送速率，防止包丢失；3 TCP 使用的流量控制协议是可变大小的滑动窗口协议；
6. **拥塞控制**：当网络拥塞时，降低发送速率；
7. **停止等待ARQ协议**：每发完一个分组就停止发送，等待对方确认，在收到确认后再发下一个分组；
8. **超时重传**：1 当 TCP 发出一个报文段后，将启动一个定时器，等待接收端确认收到此报文段；2 如果不能及时收到确认，将重发此报文段；

## ARQ协议
0. **自动重传请求（Automatic Repeat-reQuest，ARQ）**是数据链路层和传输层的错误纠正协议之⼀。它通过使⽤确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ；
1. **停止等待ARQ协议**：1 每发完⼀个分组就停止发送，等待对方确认（回复ACK）。如果过了⼀段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下⼀个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；2 优点：简单 3 缺点：信道利⽤率低，等待时间⻓；
2. **连续ARQ协议**：1 连续 ARQ 协议可提⾼信道利⽤率。发送⽅维持⼀个发送窗口，凡位于发送窗⼝内的分组可以连续发送出去，而不需要等待对⽅确认。接收⽅⼀般采⽤累计确认，对按序到达的最后⼀个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了；2 优点： 信道利⽤率⾼，容易实现；3 缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送⽅发送了 5条消息，中间第三条丢失（3号），这时接收⽅只能对前两个发送确认。发送⽅⽆法知道后三个分组的下落，而只好把后三个全部重传⼀次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的N 个消息；

## TCP 滑动窗口

1. TCP使用滑动窗口做流量控制和乱序重排；窗口是缓存的一部分，用来暂时存放字节流；
3. 发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小;
4. 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收；如果发送窗口左部的字节已发送并收到确认，就向右滑动，直到左部第一个字节不是已发送并收到确认的状态；如果接收窗口左部字节已发送确认并交付主机，就向右滑动，直到左部第一个字节不是已发送确认并交付主机的状态;
6. 接收窗口只会对窗口内最后一个按序到达的字节进行确认；例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认；发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210519201305100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

## TCP 流量控制

 1. 流量控制是为了控制发送方发送速率，保证接收方来得及接收;
 2. 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。若将窗口字段设置为 0，则发送方不能发送数据；

## TCP 拥塞控制
0. 如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度;

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210519201632308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

为了便于讨论，做如下假设：

 - 接收方有足够大的接收缓存，因此不会发生流量控制；
 - 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210419212021812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)
**1 慢开始与拥塞避免**

 - 发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...
 - 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。
 - 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

**2 快重传与快恢复**

快重传要求接收方在收到一个失序的报文段后就立即发出重复确认，发送方只要一连收到3个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计数器时间到期。

 - 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认，在收到一个失序的报文段后就立即发出重复确认，此时收到 M4，发送对 M2 的确认；收到M5，再次发送对 M2 的确认；收到M6，再次发送对 M2 的确认；
 - 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3；
 - 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免；
 - 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210419212823548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

# HTTP
## HTTP简介
1. 超文本传输协议：一个简单的请求-响应协议，运行在TCP之上，是在客户端和服务器之间传输文字、图片、音频、视频等超文本数据的约定和规范；
2. 超文本：超越了普通文本的文本，文字、图片、音频、视频、超链接等的混合体；
3. 协议：协（两个以上参与者），议（行为约定或规范）；

## HTTP常用请求方法
1. GET：从服务器请求数据；
2. POST：向服务器提交要被处理的数据（例如提交表单或上传文件）；
3. PUT：向服务器传送数据取代指定的文档内容；
4. DELETE：请求服务器删除指定页面；

## GET和POST的区别
1. GET从服务器请求数据；POST向服务器提交要被处理的数据（例如提交表单或上传文件）；
2. GET把请求的数据放在URL上，以?分隔URL和传输数据，参数之间以“&”连接，因此有安全隐患；而POST把数据放在HTTP的请求附件内（request body）；
3. GET能提交的数据量很小，通常1024字节左右，而POST通常不受限制；
4. GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）；
5. GET幂等，POST非幂等（幂等性：多次执行相同的操作，结果都是相同的。由于get是只读操作，因此是安全且幂等的；post是提交数据的操作，会修改服务器上的资源，因此是不安全且不幂等的；）；

## PUT和POST的区别
1. 幂等性：多次执行相同的操作，结果都是相同的；
2. put幂等，post不幂等：put将A修改为B，它第一次请求时值变成了B，再进行多次此请求，最终的结果还是B，所以幂等；post一次请求添加一份新资源，二次请求则添加了两份新资源，多次请求会产生不同结果，因此不幂等；
3. put应用场景：向指定URL更新资源，比如用户模块修改用户密码，每次提交得到的结果都是新更新的密码；
4. post应用场景：向指定URL创建资源，比如用户模块用户注册，每次提交都创建一个用户账号；
## HTTP为什么不用GET向服务器上传数据
0. get也可以向服务器上传数据，但是不建议，主要有两个原因;
1. 采用get向服务器上传数据时，一般将数据添加到URL后面，二者用“?”连接，参数之间以“&”连接。由于对URL的长度存在限制，因此get能上传的数据量非常小，通常在1024字节左右；而post传递数据是通过HTTP请求的附件进行，传送的数据量要大得多，一般默认为不受限制;
2. 由于get方法上传的数据是添加在URL中的，因此上传的数据被暴露，存在安全隐患，而post方法向服务器提交的内容在URL中没有明文显示，对用户不可见，安全性更好;

## HTTP长连接、短连接
1. 在HTTP/1.0中默认使⽤短连接。即客户端和服务器每进行⼀次HTTP操作，就建立⼀次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JS⽂件、图像⽂件、CSS⽂件等），每遇到这样⼀个Web资源，浏览器就会重新建立⼀个HTTP会话；
2. 从HTTP/1.1起，默认使用长连接，⽤以保持连接特性。使⽤长连接的HTTP协议，会在响应头加入这行代码：`Connection:keep-alive`。在使⽤⻓连接的情况下，当⼀个网页打开完成后，客户端和服务器之间⽤于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使⽤这⼀条已经建⽴的连接。Keep-Alive不会永久保持连接，它有⼀个保持时间，可以在不同的服务器软件中设定这个时间。实现长连接需要客户端和服务端都⽀持⻓连接；
3. HTTP协议的⻓连接和短连接，实质上是TCP协议的⻓连接和短连接；
## HTTP是不保存状态的协议,如何保存用户状态
1. HTTP 是⼀种不保存状态即⽆状态协议。即HTTP 协议⾃身不对请求和响应之间的通信状态进⾏保存。那么如何保存⽤户状态呢？Session 机制的存在就是为了解决这个问题；
2. Session 的主要作⽤就是通过服务端记录⽤户的状态。典型的场景是购物⻋，当用户要添加商品到购物⻋的时候，系统不知道是哪个⽤户操作的，因为 HTTP是⽆状态的。服务端给特定的⽤户创建特定的Session 之后就可以标识这个⽤户并且跟踪这个⽤户了;
3. Session 存放在服务端，通过在Cookie 中附加⼀个Session ID发至客户端并由客户端之后再请求时带上Cookie被识别的⽅式，来实现用户状态的保持；
4. 在服务端保存 Session 的⽅法很多，最常⽤的就是内存数据库(比如redis)；
5. Cookie 被禁⽤怎么办：利⽤ URL 重写把 Session ID 直接附加在URL路径的后⾯；
## HTTP 1.0和HTTP 1.1的主要区别是什么
1.  **长连接** : 在HTTP/1.0中，默认使⽤的是短连接，也就是说每次请求都要重新建⽴⼀次连接。而HTTP 是基于TCP/IP协议的，每⼀次建⽴或者断开连接都需要经过三次握⼿四次挥⼿，开销比较⼤。从HTTP 1.1起，默认使⽤⻓连接，默认开启Connection： keep-alive。 HTTP/1.1的长连接有⾮流⽔线⽅式和流⽔线⽅式 。流⽔线⽅式是客户端在收到HTTP的响应报⽂之前就能接着发送新的请求报⽂，而⾮流⽔线⽅式是客户端在收到前⼀个响应后才能发送下⼀个请求；
2. **错误状态响应码** :在HTTP1.1中新增了错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发⽣冲突；410（Gone）表示服务器上的某个资源被永久性删除；
3. **缓存处理** :在HTTP1.0中主要使⽤Expires、If-Modified-Since来作为缓存控制策略，HTTP1.1则引入了更多的缓存控制策略如Entity tag（一个标识文件特定版本的标记）、If-Unmodified-Since, If-Match, If-None-Match等；
4. **带宽优化及网络连接的使用**：HTTP1.0中，存在⼀些浪费带宽的现象，例如客户端只需要某个对象的⼀部分，而服务器却将整个对象送过来了，并且不⽀持断点续传功能；HTTP1.1则在请求头中引入了range，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就⽅便了开发者⾃由的选择以便充分利⽤带宽；

## HTTP和HTTPS的区别？
1. **端口**：HTTP的URL由”http://"起始且默认使用端口80，而HTTPS的URL由“https://"起始且默认使用端口443；
2. **安全性和资源消耗**：1 HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器都无法验证对方身份；2 HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密；3 因此HTTPS安全性比HTTP高，但HTTPS比HTTP耗费更多服务器资源；

## HTTP状态码
|  | 类别 | 原因短语 |
|:--------:|:--------:| :-------------:|
|1XX|Informational（信息性状态码）|信息，服务器收到请求，需要请求者继续执行操作|
|2XX|Success（成功状态码）|成功，操作被成功接收并处理|
|3XX|Redirection（重定向状态码）|重定向，需要进一步的操作以完成请求|
|4XX|Client Error（客户端错误状态码）|客户端错误，请求包含语法错误或无法完成请求|
|5XX|Server Error（服务器错误状态码）|服务器错误，服务器在处理请求的过程中发生了错误|

# 其他
## URI和URL的区别
1. URI（Uniform Resource Identifier）是统一资源标识符，可以唯一标识一个资源；
2. URL（Uniform Resource Location）是统一资源定位符，可以提供该资源的路径信息，是一种具体的URI；
3. URI类似身份证号，URL类似家庭住址；

## Cookie和Session
HTTP作为无状态协议，必然需要以某种方式保持连接状态，于是出现了Cookie和Session技术。

### Cookie
1. Cookie是客户端保持状态的方法；
2. Cookie其实就是由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器在响应客户端请求时将Cookie放在Set-Cookie下，客户端收到后保存Cookie，之后再请求时带上Cookie就可以被识别；
3. Cookie在客户端的保存形式有两种，一种是会话Cookie一种是持久Cookie。会话Cookie就是将服务器返回的Cookie保持在内存中，关闭浏览器之后自动销毁；持久Cookie则是存储在客户端所在磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。存储在磁盘中的Cookie可以被多个浏览器代理共享；

### Session
1. Session是服务端保持状态的方法；
2. Session可以存储在服务器上的文件、数据库或者内存中，也可以存储在 Redis 这种内存型数据库中，效率会更高；
3. Session的工作原理是：1 客户端登录服务器成功后，服务器创建对应的Session用来保存用户的会话信息，同时分配一个唯一的SessionID；2 服务器向客户端发送一个Cookie，Cookie中存储这个SessionID，客户端将此Cookie保存；3 客户端再次登录服务器时，将请求和此Cookie一起提交给服务器；4 服务器提取出SessionID后，找到对应的Session，继续之前的业务操作；
4. 注意：SessionID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 SessionID值。此外，还需要经常重新生成 SessionID。在对安全性要求极高的场景下，例如转账等操作，除了使用Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式；

### Session的Redis存储案例
1. 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
2. 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 为SessionID；
3. 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个SessionID，客户端收到响应报文之后将该Cookie存入浏览器中；
4. 客户端之后对同一个服务器进行请求时会包含该Cookie，服务器收到之后提取出SessionID，从Redis 中取出用户信息，继续之前的业务操作；

```java
 **cookie和session的区别**
	- 存放位置：cookie存放在客户端，session存放在服务器；
	- 安全程度：cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑安全应当使用session；
	- 性能使用程度：session会在一定时间内保存在服务器上，当访问增多，会比较占用服务器的内存，考虑到减轻服务器负担，应当使用cookie；
	- 存储数据大小：单个cookie保存的数据不能超过4K，而session没有存储大小的限制；
```

## 从输入URL到页面加载发生了什么
1. DNS解析URL对应的IP；
2. 根据IP建立TCP连接（三次握手）；
3. 发送HTTP请求；
4. 服务器处理请求并返回数据资源：在服务端实际上还有很复杂的业务逻辑，服务器可能有多台，到底指定哪台服务器来处理请求，这需要一个负载均衡设备来平均分配所有用户的请求；
5. 浏览器解析渲染页面，发现还有一些静态资源（如CSS、JS或图片）时又会发起另外的HTTP请求，而这些请求很可能会在CDN（内容分布网络）上，那么CDN服务器又会处理这些请求；
## DNS
**域名系统**（Domain Name System，DNS）是将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网；

 **域名解析**：
 
 举例说明：baike.baidu.com作为一个域名和IP地址202.108.23.50 相对应。DNS就像是一个自动的电话号码簿，我们可以直接拨打202.108.23.50的名字baike.baidu.com来代替电话号码（IP地址）。

DNS查询有两种方式：递归和迭代。DNS客户端设置使用的DNS服务器一般都是递归服务器，它负责全权处理客户端的DNS查询请求，直到返回最终结果。

以查询baike.baidu.com为例：

客户端发送查询报文"query baike.baidu.com"至DNS服务器，DNS服务器首先检查自身缓存，如果存在记录则直接返回结果。

如果记录老化或不存在，则：

 1. DNS服务器向根域名服务器发送查询报文"query baike.baidu.com"，根域名服务器返回顶级域 .com的顶级域名服务器地址；
 2. DNS服务器向 .com 域的顶级域名服务器发送查询报文"query baike.baidu.com"，得到二级域 .baidu.com 的权威域名服务器地址；
 3. DNS服务器向 .baidu.com 域的权威域名服务器发送查询报文"query baike.baidu.com"，得到主机 baike 的A记录，存入自身缓存并返回给客户端。

## 几种常见协议
1. OSPF：开放式最短路径优先。是一种基于IP协议的路由选择协议，采用Dijkstra算法来计算最短路径树；
2. ARP：地址解析协议，是根据IP地址获取MAC地址的一个TCP/IP协议；
3. HTTP：一个简单的请求-响应协议，运行在TCP之上，是在客户端和服务器之间传输文字、图片、音频、视频等超文本数据的约定和规范；

# 网络编程
## TCP编程的核心步骤
![在这里插入图片描述](https://img-blog.csdnimg.cn/dc3b09278317494cbdff6c053f2a477e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

1. 客户端的connect() 函数，功能是为客户端主动连接服务器，建立连接是通过三次握手，而这个连接的过程是由内核完成，而不是这个函数完成的，这个函数的作用仅仅是通知计算机内核，让计算机内核完成TCP三次握手连接，最后把连接的结果返回。通常的情况，客户端的connect() 函数默认会一直阻塞，直到三次握手成功或超时失败才返回；
2. 服务端的bind()函数，功能是把一个本地协议地址赋予一个套接字。对于网际协议，协议地址是32位的IPv4地址或是128位的IPv6地址与16位的TCP或UDP端口号的组合；
3. 服务端的listen()函数，功能是使主动连接套接字变为被动连接套接字，使得一个进程可以接受其他进程的请求，从而成为一个服务器进程；
4. 简言之，listen()是进入监听状态，表示愿意接收连接请求。listen()之后有连接请求就将其放到队列中，accept()是把新连接请求从队列中取出，建立新的socket。注意UDP的套接字不需要listen，只有TCP的套接字监听才要listen。UDP的套接字bind需要监听的端口就可以接收数据了；
