@[TOC](目录)
# 教材内容
## 什么是封锁？基本的封锁类型有几种？试述它们的含义。
1. 封锁：事务对数据操作前，向系统请求封锁，释放锁前，其他事务不能更新数据；
2. 两种：排它锁（写锁，X锁）和共享锁（读锁，S锁）；
3. 排它锁：T对A加X锁，只允许T读取修改A，其他事务不能对A加锁、不能读取修改A，直到T释放锁；
4. 共享锁：T对A加S锁，T可以读A不能修改A，其他事务只能对A加S锁不能加X锁，直到T释放锁；
## 什么是活锁？试述活锁产生的原因和解决方法。
1. T1封锁A；
2. T2请求封锁A，等待；
3. T3请求封锁A，T1释放锁后，先批准T3，T2等待；
4. T4请求封锁A，T3释放后，批准T4，T2又等待，...可能一直等待；
5. 原因：封锁不按先后顺序执行，导致有些事务无限期等待，产生活锁；
6. 解决方法：采用先来先服务（FTFS）策略；
## 什么是死锁？试给出预防死锁的方法
1. T1封锁R1，T2封锁R2，T1又请求封锁R2，T2又请求封锁R1;
2. 出现T1等T2，T2等T1的局面，两事务永远不结束;
3. 防止策略：（1一次封锁法：要求事务一次把所有要用的数据全部加锁2顺序封锁法：对数据对象规定封锁顺序，所有事务按这个顺序封锁）;
## 试给出检测死锁的一种方法。当发生死锁后，如何解除死锁？
1. 超时法：事务等待时间超过规定时限，认为死锁，可能误判；
2. 解除方法：选择代价最小的事务，将其撤销，释放它所有锁，让其他事务运行，对撤销事务所执行的数据修改操作进行恢复；

## 超键、候选键、主键、主属性、非主属性
 - 超键：在关系中能唯一标识元组的属性集称为关系模式的超键；
 - 候选键：不含有多余属性的超键称为候选键。也就是关系中的一个属性组，其值能唯一标识一个元组。若从属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称作候选键；
 - 主键：从关系的多个候选键中，选定一个作为主键；
 - 主属性：在任何一个候选键中的属性称作主属性；
 - 非主属性：不在任何候选键中的属性；
## 实体完整性和参照完整性
 - 实体完整性：关系的主码唯一并且主码的各属性不能取空;
 - 参照完整性：外码的值要么取空要么等于被参照关系某个元组的主码值;
## 为什么外码的属性值可以为空？什么情况下可以为空
 - 为空表示该属性值尚未确定;
 - 前提是该外码属性不是其所在关系的主属性3例如“学生表”，专业号是外码，不是“学生表”主属性，可以取空；在“选修表”中，课程号是外码，但同时是“选修表”的主属性，不能取空;

## 数据库如何保证一致性
**一致性**：数据库只包含成功事务提交的结果时，就处于一致性，否则不一致。

1. 数据库层面：通过原子性、隔离性和持续性来保证一致性。即ACID特性中，一致性是目的，原子性、隔离性和持续性都是手段；
2. 应用层面：通过代码判断数据库数据是否有效，然后决定回滚还是提交数据；

# 数据库
## 关系型和非关系型数据库

 - 关系型：1 采用关系模型来组织数据；2 可以保持数据的一致性； 3 支持复杂查询（where子句）；
 - 非关系型：1 也称NoSQL，采用键值对的形式进行存储；2 不需要经过SQL层的解析，读写性能高、易于扩展；3 可以支持多种类型数据的存储，如图片、文档等；

## 数据库结构优化
1. 可适当违反第三范式，减少join操作；
2. 设计一些中间表；
3. 对表进行垂直拆分：常用字段单独一个表，不常用字段单独一个表，大字段单独一个表；
4. 对表进行水平拆分：将一个表中的记录拆分到多个结构相同的表中；
5. 主键尽量自增；

 [参考链接](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN%23rd).
## SQL语句查询顺序
select > from > where > group by > having > order by > limit

## 解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?
1. 池化设计即初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。就好比去⻝堂打饭，打饭的⼤妈会先把饭盛好几份放那里，你来了就直接拿着饭盒加菜即可，不⽤再临时打饭，效率就⾼了。除了初始化资源，池化设计还包括如下这些特征：池⼦的初始值、池⼦的活跃值、池⼦的最⼤值等。这些特征可以直接映射到java线程池和数据库连接池的成员属性中；
2. 数据库连接池：数据库连接本质就是⼀个 socket 的连接。数据库服务端还要维护⼀些缓存和⽤户权限信息等，因此占⽤了⼀些内存。为⽤户打开和维护数据库连接，尤其是对动态数据库驱动的⽹站应⽤程序的请求，既昂贵⼜浪费资源。有了数据库连接池，创建连接后，就将其放在池中，并再次使⽤它，因此不必建⽴新的连接。如果使⽤了所有连接，则会建⽴⼀个新连接并将其添加到池中；

## 1/2/3NF
为了在数据库设计中更好地解决数据冗余和数据有效性检查，提高存储效率，提出了范式的概念。
### 1NF
概念：每一个分量必须是不可分的数据项（即不能以集合、序列等作为属性）；

举例

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210712155618591.png)
它就不满足1NF，因为{C1，C2，C3}和{C1，C4}是集合。

修改为符合1NF：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210712155640522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

### 2NF
概念：在1NF基础上，消除非主属性对键的部分依赖；

举例，对于Student表：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210712155724966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)
（学生编号、课程编号）是键，对于“学生姓名”、“班级编号”、“院系”这三个非主属性来说，可以直接通过“学生编号”来确定，“课程编号”显得多余，即“学生姓名”、“班级编号”、“院系”对（学生编号、课程编号）部分函数依赖。把Student表进行拆分，可以消除部分依赖。

其中，学生表Student如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021071216031768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

学生-课程表如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210712160355881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

### 3NF
概念：在2NF基础上，消除非主属性对键的传递依赖；

根据上面对传递依赖的分析，对于Student表，学生编号可以唯一确定他所在的院系，但是注意到这中间存在传递过程，即学生编号唯一确定该学生所对应的班级编号，班级编号对应唯一的院系。我们称，院系对学生编号传递函数依赖。

把Student表继续进行拆分，可以消除传递依赖。

其中，学生表Student如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210712160630659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)
班级-院系表如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210712160652257.png)

## inner join、outer join 和 full join
1. inner join（内连接）：返回两表中连接字段相等的记录；
2. outer join（外连接）
	- left join（左外连接）
		左外连接是左表的所有数据都显示出来，右表数据只显示共有的那部分，不共有的部分只能填空显示。
	- right join（右外连接）
		右外连接是右表的所有数据都显示出来，左表数据只显示共有的那部分，不共有的部分只能填空显示。
3. full join（全连接）：返回两表所有数据，但是去除两表的重复数据。

## SQL注入攻击

攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。例如用户登录：输入用户名 lisan，密码 ‘ or ‘1’=’1 ，如果此时使用参数构造的方式，就会出现select * from user where name = ‘lisan’ and password = ‘’ or ‘1’=‘1’，不管用户名和密码是什么内容，上述查询语句是永远可以查询出结果的。

如何防范SQL注入攻击使用预编译的PrepareStatement是必须的，但是一般我们会从两个方面同时入手：

 1. Web端：1 有效性检验； 2 限制字符串输入的长度；
 2. 服务端：1 不用拼接SQL字符串；2 使用预编译的PrepareStatement；3 有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求)；4 过滤SQL需要的参数中的特殊字符。比如单引号、双引号；

# MySQL
## MySQL是如何执行一条SQL的？具体步骤有哪些？
Server层按顺序执行SQL的步骤为：

1. 客户端请求；
2. 连接器（验证用户身份，给予权限）；
3. 查询缓存（存在缓存则直接返回，不存在则执行后续操作）；
4. 分析器（对SQL进行词法分析和语法分析操作）；
5. 优化器（选择它认为最优的执行方案）；
6. 执行器（执行前先看用户是否有执行权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口）；
7. 去存储引擎层获取数据返回（如果开启查询缓存还会缓存查询结果）；

## MySQL的内部构造一般分哪两个部分？
分服务层和存储引擎层。

1. 服务层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块；
2. 存储引擎层：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210710115040634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)

## delete、truncate和drop的区别
1. delete删除表中数据，可以加where字句部分删除;
2. Truncate删除表中全部数据，再插入时自增长id又从1开始 ;
3. drop直接删掉表;
4. **应用场景**：想删除部分数据行时用delete；保留表而删除所有数据的时用truncate；不再需要一张表时用drop；

## binlog、redo logo、undo log的区别
0. MySQL可划分为服务层和引擎层。bin log是在服务层实现的，redo log、undo log是在引擎层实现的，且是innodb引擎独有的；
1. **binlog**：即归档日志，记录的是对整个MySQL数据库的操作内容，包括执行的DDL、DML，对所有的引擎都适用，用来进行数据库的恢复及复制。依靠binlog没有crash-safe能力(crash-safe能力即使数据库发生异常重启，之前提交的记录都不会丢失)；
2. **redo log**：即重做日志，记录的是数据修改之后的值，如果一条数据已提交成功，不会立即同步到磁盘，而是先记录到redo log中，等待合适的时机再刷盘。在数据库发生异常重启的时候，可以根据redo log日志进行恢复，也就达到了crash-safe；
3. **undo log**：即回滚日志，记录的是当前操作中的相反操作，一条insert语句在undo log中会对应一条delete语句，update语句会在undo log中对应相反的update语句，在事务回滚时会用到undo log，实现事务的原子性；


> redo log是物理日志，记录该数据页更新的内容；binlog是逻辑日志，记录的是这个更新语句的原始逻辑；
> binlog可以作为数据恢复和主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用；

## MySQL更新语句分析

```sql
UPDATE tb_student SET age='19'
WHERE name=' 张三 ';
```

更新语句和查询语句类似，只不过执行更新的时候要记录日志。MySQL自带的日志模块为binlog(归档日志），所有的存储引擎都可以使用，InnoDB引擎还自带了一个日志模块redo log(重做日志），下面以InnoDB模式来探讨语句的执行流程。流程如下：

 1. 先查询到“张三”这一条数据，如果有缓存，也还是会用到缓存；
 2. 拿到查询的语句，把age改为19，然后调用引擎API接口，写入这一行数据，InnoDB引擎把数据保存在内存中，同时记录redo log；此时redo log进入prepare状态，然后告诉执行器，执行完成了，随时可以提交；
 3. 执行器收到通知后记录binlog，然后调用引擎接口，提交redo log为commit状态；
 4. 更新完成；

**问：为什么要用两个日志模块，用一个日志模块不行吗?**

这是因为最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。

并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？

 - 先写 redo log 直接提交，然后写 binlog，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。
 - 先写 binlog，然后写 redo log，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。

如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：

 - 如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交；
 - 如果redo log里面的事务只有完整的prepare，则判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务；

这样就解决了数据一致性的问题。

## MySQL中为什么要有事务回滚机制
 在 MySQL 中，恢复机制是通过回滚日志（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再对数据库进行写入。 当事务已经提交，就无法再回滚了；

回滚日志作用：
1. 能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息；
2. 在系统发生崩溃或数据库进程直接被杀死后，当用户再次启动数据库进程时，能够通过查询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后写数据库的主要原因；
## InnoDB和MyISAM的区别
0. 都是数据库存储引擎，存储数据和提供读写接口，InnoDB是MySQL默认的存储引擎；
1. **事务和崩溃后的安全恢复**：InnoDB支持事务，具有事务、回滚和崩溃修复能力的事务安全型表；MyISAM不支持事务，崩溃后无法安全恢复；
2. **是否支持MVCC**：InnoDB支持，MyISAM不支持。应对高并发事务，MVCC比单纯的加锁更高效；
3. **锁粒度**：InnoDB既支持表锁，又支持行锁，默认是行锁；MyISAM只支持表锁；
4. **索引结构**：InnoDB聚簇索引，MyISAM非聚簇索引；
5. **主键**：InnoDB的表必须有主键，如果没有设定主键，会自动生成一个主键，MyISAM允许没有主键的表存在；
6. **外键**：InnoDB支持，MyISAM不支持；

## 表级锁和行级锁对比
 - **表级锁**：MySQL中锁定粒度最大的⼀种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最⼤，触发锁冲突的概率最⾼，并发度最低，MyISAM和InnoDB引擎都⽀持表级锁；
 - **行级锁**： MySQL中锁定粒度最小的⼀种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度⾼，但加锁的开销也最大，加锁慢，会出现死锁；

## MySQL字符集及校对规则
1. 字符集指的是⼀种从⼆进制编码到某类字符符号的映射，校对规则是在字符集内用于比较字符的一套规则；
2. MySQL采⽤类似继承的⽅式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承。比如：某个库中所有表的默认字符集将是该数据库所指定的字符集（这些表在没有指定字符集的情况下，将会采⽤默认字符集）；

## char和varchar
1. char长度不可变，用空格填充到指定长度大小；varchar长度可变；
2. char存取速度比varchar快得多；varchar根据传入的值分配长度，更智能；
3. char的存储方式是：1个英文字符占1个字节，1个汉字占2个字节；varchar的存储方式是：1个英文字符或1个中文字符都占2个字节；
4. 当某个字段的数据长度为定长时，选择char，例如性别、生日等；当某个字段的数据长度不确定时，选择varchar，例如姓名、简介等；

## 数据库备份方式和备份策略
**1. 备份方式**

 - 热备份：当数据库进行备份时，数据库的读写操作均不受影响
 - 温备份：当数据库进行备份时，数据库的读操作可以进行，但不能执行写操作
 - 冷备份：当数据库进行备份时，数据库不能进行读写操作

**2. 备份策略**

 - **1 直接复制数据库文件**
   
   针对数据量较小的场景。

 - **2 mysqldump + binlog**
   
   针对数据量适中的场景。mysqldump 对数据库进行完全备份，定期备份 binlog 达到增量备份的效果。
   
   mysqldump 实际上就是将表结构和数据存储在文本文件中，原理：先根据表结构生成 CREATE 语句，然后再将数据转换为 INSERT 语句

 - **3 ivm2 快照 + binlog**
   
(注：binlog 即二进制日志，记录对数据发生或者潜在发生更改的 SQL 语句，以二进制形式保存在文件中。)

## InnoDB为什么使用自增id作为主键
1. 如果使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页；
2. 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置， 频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE（optimize table）来重建表并优化填充页面；

# 事务
## 试述事务的概念及事务的4个特性
1. **概念**：数据库操作序列，要么全做要么全不做，不可分割的工作单位；
2. **特性**：原子性一致性隔离性持续性，简称ACID特性；
3. **原子性**：事务中各项操作要么全做要么全不做；
4. **一致性**：数据库只包含成功事务提交的结果时，就处于一致性，否则不一致；
5. **隔离性**：一个事务的执行不被其他事务干扰；
6. **持续性**：即永久性，事务一旦提交，对数据库数据的改变是永久性的；

## 并发操作可能会产生哪几类数据不一致
1. 丢失修改：T1修改一数据，T2随后修改，T2覆盖T1，T1的修改丢失；
2. 读“脏”数据：T1修改一数据，T2随后读取，T1因故撤销修改，T2读取的就是脏数据；
3. 不可重复读：T1读取一数据，T2修改数据，T1再次读取这个数据，读取结果和第一次读取结果不同；
4. 幻读：T1 读取某个范围的数据，T2 在这个范围内更新数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同；

## 不可重复读和幻读区别是什么？
不可重复读的重点是修改，幻读的重点在于新增或者删除。

 - 不可重复读：同样的条件, 你读取过的数据, 再次读取出来发现值不一样；
 - 幻读：同样的条件, 第1次和第2次读出来的记录数不一样；

## 事务隔离级别
0. 数据库产生并发不一致问题主要是因为破坏了事务的隔离性 ，可以通过并发控制（如封锁机制）来保证隔离性，但比较复杂，数据库管理系统提供了事务隔离级别（4种），可让用户以一种更轻松的方式保证隔离性；
1. 未提交读：事务中的修改，即使没有提交，对其它事务也是可见的；
2. 提交读：一事务只能读取已提交的事务所做的修改；
3. 可重复读：保证在同一事务中多次读取同样数据的结果是一样的；
4. 可串行化：强制事务串行执行 ；

## MVCC
**MVCC**（Multi-Version Concurrency Control，多版本并发控制）：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁和写锁就不冲突了，不同的事务session会看到自己特定版本的数据。MVCC只在READ COMMITED和REPEATABLE READ两个隔离级别下工作，其他两个隔离级别和MVCC不兼容，因为READ UNCOMMITED总是读取最新的数据行，而不是符合当前事务版本的数据行，而SERIALIZABLE会对所有读取的行都加锁。
## MySQL 中事务隔离级别的实现
1. **未提交读**：总是读取最新的数据行；
2. **提交读**：使用 MVCC的当前读，读取的是最新的数据，有可能会出现一个事务中两次读到了不同的结果；
3. **可重复读**：使用MVCC的快照读，读取的是小于等于此事务的数据，也就实现了可重复读；
4. **可串行化**：以悲观锁为理论基础，读加共享锁（S），写加排他锁（X），读写互斥；

## 事务并发访问引起的问题及使用哪种事务隔离级别避免+1
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210418162034761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjMTc5,size_16,color_FFFFFF,t_70)


# 表优化
## 大表优化
0. 当MySQL单表记录数过⼤时，数据库的CRUD性能会明显下降，⼀些常见的优化措施如下：1 限定数据的范围 2 读写分离 3 垂直分区 4 水平分区；
1. **限定数据的范围**：禁止不带任何限制数据范围条件的查询语句；
2. **读写分离**：经典的数据库拆分方案，主库负责写，从库负责读；
3. **垂直分区**：指数据表列的拆分，把⼀张列比较多的表拆分为多张表。优点：简化表结构，易于维护，在查询时减少读取的Block数，减少I/O次数；缺点：主键会出现冗余，会引起Join操作，会让事务变得更复杂；
4. **水平分区**：⽔平拆分是指数据表行的拆分，保持数据表结构不变，通过某种策略存储数据分片；每个数据分片分散到不同的表或者库中，达到了分布式的目的；

## 分库分表
为了解决由于数据量过大而导致数据库性能降低的问题，将单一数据库拆分成若干数据库，将单一数据表拆分成若干数据表，从而提升数据库性能；

### 分表

可以减少数据库的单表负担，将压力分散到不同表上，提高了查询性能和并发度。

1. 水平分表：把一个表的数据按照一定规则拆分到多个表中。比如取模分表就属于随机分表，而时间维度分表则属于连续分表；
2. 垂直分表：把一个表按照字段拆分成多个表。比如常用字段单独一个表，不常用字段单独一个表，大字段单独一个表；

### 分库

库内分表，仅仅是解决了单表数据过大的问题，但并没有把单表的数据分散到不同的物理机上，因此并不能减轻 MySQL 服务器的压力，仍然存在同一个物理机上的资源竞争和瓶颈，包括 CPU、内存、磁盘IO、网络带宽等。因此还需要分库。

1. 水平分库：把一个表的数据按照一定规则拆分到不同数据库中，不同数据库放在不同服务器上；
2. 垂直分库：按照业务将表进行垂直拆分，然后分布到不同数据库中，不同数据库放在不同服务器上；

### 分库分表之后，id 主键如何处理
因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要⼀个全局唯⼀的 id 来⽀持。⽣成全局 id 有下⾯这⼏种⽅式：
1. UUID（通用唯一识别码）：不适合作为主键，因为太⻓了，并且⽆序不可读，查询效率低。比较适合⽤于⽣成唯⼀的名字的标识⽐如⽂件的名字；
2. 数据库自增 id：两台数据库分别设置不同步⻓，⽣成不重复ID的策略来实现⾼可⽤。这种⽅式⽣成的 id 有序，但是需要独⽴部署数据库实例，成本⾼，还会有性能瓶颈；
3. 利⽤ redis ⽣成 id : 性能比较好，灵活⽅便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可⽤性降低，编码更加复杂，增加了系统成本；
4. 美团的Leaf分布式ID⽣成系统 ：Leaf 是美团开源的分布式ID⽣成器，能保证全局唯⼀性、趋势递增、单调递增、信息安全；

### 分库分表带来的分布式困境及应对之策
1. 数据迁移与扩容问题：先通过程序读出数据，再按照指定的分表策略将数据写入到各个分表中；
2. 分页与排序问题：先在不同的分表中将数据排序并返回，再将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户；

# 索引
## 索引
0. 索引是对数据库表中一列或多列的值进行排序的结构，好比一本书的目录，可以提高查询效率，但同时耗费了数据库存储空间，在插入和修改时也需花费更多的时间(因为索引也要随之变动)；
1. 聚簇索引：索引项顺序与表记录的物理顺序一致，叶子结点存储真实的数据行，不再有另外单独的数据页；
2. 非聚簇索引：索引项顺序与表记录的物理顺序不一致，叶子结点存储索引字段值和数据页数据行的地址。
3. 唯一索引：不允许具有索引值相同的行，索引值可以为NULL但不能有多个NULL；
4. 主键索引：唯一索引的特殊类型，主键作为索引(默认)；
## HASH索引
1. 底层数据结构是哈希表，采用哈希算法把键值换算成哈希值，以O(1)时间查找，速度快但失去了有序性；
2. 在绝大多数需求为单条记录查询时，选择哈希索引查询性能最好；
3. 不足：(1)无法用于排序和分组(2)只支持精确查找，无法用于范围查找(3)遇到大量哈希冲突的情况效率大大降低(4)不能避免全表扫描；

## MySQL中的索引
MySQL索引使⽤的数据结构主要有BTree索引 和 哈希索引 。对于HASH索引来说，底层的数据结构就是HASH表，因此在绝⼤多数需求为单条记录查询的时候，可以选择HASH索引，查询性能最快；其余⼤部分场景，建议选择BTree索引。

MySQL的索引使⽤的是B+Tree，但对于主要的两种存储引擎的实现方式是不同的。

 - MyISAM：B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，⾸先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“⾮聚簇索引”；
 - InnoDB: 树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，这被称为“聚簇索引”。⽽其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值⽽不是地址，这也是和MyISAM不同的地⽅。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再⾛⼀遍主索引。 因此，在设计表的时候，不建议使⽤过⻓的字段作为主键，也不建议使⽤⾮单调的字段作为主键，因为会造成主索引频繁分裂；

## 创建索引要注意什么？
1. 选择离散大的字段：可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多，即字段的离散程度越高；
2. 选择非NULL字段：在 MySQL 中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替空值；
3. 选择经常被查询的字段；
4. 字段值越小越好：字段越小查询时IO次数越少，效率越高；
5. **总之**：唯一、不为空、经常被查询、字段值小的字段适合建索引；

## MySQL索引使用的注意事项
MySQL 索引通常是被用于提高 WHERE 条件的数据行匹配时的搜索速度，在索引的使用过程中，存在一些使用细节和注意事项。

1. 尽量避免在where中使用函数或进行运算，将导致索引失效而进行全表扫描；

```java
select * from news where year(publish_time) < 2017
```
改造成

```java
select * from news where publish_time < '2017-01-01'
```

```java
select * from news where id / 100 = 1
```
改造成

```java
select * from news where id = 1 * 100
```
2. 尽量避免在where中使用 != 或 not in或 <> 等否定操作符，将导致索引失效而进行全表扫描；
3. 尽量避免在where中使用or来连接条件，将导致索引失效而进行全表扫描；
4. 多个单列索引并不是最佳选择：MySQL 只能使用一个索引，会从多个索引中选择一个限制最为严格的索引，因此，为多个列创建单列索引，并不能提高 MySQL 的查询性能。假设，有两个单列索引，分别为 news_year_idx(news_year) 和 news_month_idx(news_month)。现在，有一个场景需要针对资讯的年份和月份进行查询，那么，SQL 语句可以写成：`select * from news where news_year = 2017 and news_month = 1`。事 实 上 ， MySQL 只 能 使 用 一 个 单 列 索 引 。 为 了 提 高 性 能 ， 可 以 使 用 复 合 索 引news_year_month_idx(news_year, news_month) 保证 news_year 和 news_month 两个列都被索引覆盖；

## B树
1. 一个结点存放多个键值对，键升序排列，左小于根小于右;
2. 对M阶B树：根结点至少两个子结点，每个结点最多M个子结点，除根节点和叶子节点外其他节点至少有 m/2 个子结点，所有叶子节点都在同一层；
3. B树的阶数一般比较大，即使存储大量数据，高度依然很小;
4. 磁盘IO代价主要花费在查找上，而查找的次数由树的高度决定，在大规模数据存储时，平衡二叉树往往由于树的高度过大而造成磁盘I/O过于频繁，导致效率低下，因此采用B树进行存储；
5. 文件系统设计者将B树一个结点的大小设为等于一个页（1024字节或其整数倍），这样只需一次I/O就可以完全载入一个结点（磁盘预读原理）;
6. 3层B树可以容纳1024*1024*1024差不多10亿个数据，假定操作系统一次读取一个结点，那么B树在10亿个数据中查找目标值，只需小于3次磁盘读取就可以找到，大大提高了I/O的效率；

## B+树+1
1. B树的一种变形;
2. 不同点：（1）非叶子结点仅具有索引作用，只存储key，不存储value；（2）所有叶子结点构成一个按key排序的有序链表;
3. 为什么数据库索引选择B+树而不是B树：（1）B+树高度更小：相较于B树B+树每个叶子结点存储的关键字数更多，所以树高更小查询更快；（2）B+树查询速度更稳定：B+树所有数据都存在叶子结点上，所有关键字查询的路径长度相同，因此查询速度更加稳定；（3）B+树天然具备排序功能：B+树所有叶子结点构成一个有序链表，因此区间查询效率高，而在数据库中基于区间的查询是非常频繁的；（4）B+树全结点遍历更快：B+树遍历整棵树只需线性遍历叶子结点即可;

## 聚集索引、辅助索引、覆盖索引
 
1. **聚集索引**（主键索引）：索引项顺序与表记录的物理顺序一致，叶子结点存储真实的数据行，不再有另外单独的数据页；
2. **辅助索引**（二级索引）：非主键索引，叶子节点=键值+书签。Innodb存储引擎的书签就是相应行数据的主键索引值；
3. **覆盖索引**：select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。







