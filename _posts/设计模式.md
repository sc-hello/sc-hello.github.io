@[TOC](目录)
# 1 简单工厂模式+1
## 简介
1.  定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例具有共同的父类；
2. 优点：（1）屏蔽产品的具体实现，调用者想创建一个对象，只要知道其名称即可；（2）扩展性高，如果想增加一个产品，只要增加一个实体类即可;
3. 缺点：会增加系统中类的个数（引入新的工厂类），增加了系统的复杂度；
4. 应用场景：数据库访问，用户不确定系统最终采用哪一类数据库；

## 实现
### 1 创建一个 Shape 接口

Shape.java

```java
public interface Shape {
   void draw();
}
```

### 2 创建若干实现 Shape 接口的实体类

Rectangle.java

```java
public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
```

Square.java

```java
public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}
```

Circle.java

```java
public class Circle implements Shape {

   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}
```


### 3 创建工厂类 ShapeFactory，ShapeFactory内部定义函数Shape getShape(String shapeType)用于返回基于给定信息的实体类对象

ShapeFactory.java

```java
public class ShapeFactory {
    
   //使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
}
```

### 4 创建工厂对象，通过传递类型信息来获取实体类的对象

FactoryPatternDemo.java

```java
public class FactoryPatternDemo {
 
   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();
 
      //获取 Circle 的对象，并调用它的 draw 方法
      Shape shape1 = shapeFactory.getShape("CIRCLE");
 
      //调用 Circle 的 draw 方法
      shape1.draw();
 
      //获取 Rectangle 的对象，并调用它的 draw 方法
      Shape shape2 = shapeFactory.getShape("RECTANGLE");
 
      //调用 Rectangle 的 draw 方法
      shape2.draw();
 
      //获取 Square 的对象，并调用它的 draw 方法
      Shape shape3 = shapeFactory.getShape("SQUARE");
 
      //调用 Square 的 draw 方法
      shape3.draw();
   }
}
```

```java
Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.
```

# 2 单例模式+1
## 简介
1. 确保类仅有一个实例，并提供一个访问它的全局访问点。
2. 应用场景：许多时候系统只需要拥有一个全局对象，这有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息，如此就简化了在复杂环境下的配置管理。 

## 实现一：线程不安全的懒汉式
**是否懒初始化**：是

**是否多线程安全**：否

**实现难度**：易

**描述**：这种方式没有加锁，因此不支持多线程，严格意义上并不算单例模式。
```java
public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
    public static Singleton getInstance() {  
	    if (instance == null) {  
	        instance = new Singleton();  
	    }  
	    return instance;  
    }  
}
```

## 实现二：双重校验锁的实现方式

**是否懒初始化**：是

**是否多线程安全**：是

**实现难度**：较复杂

**描述**：这种方式采用synchronized+volatile，实现了懒初始化、线程安全且能保持高性能。

```java
public class Singleton {  
    private volatile static Singleton instance;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
	    if (instance == null) {  
	        synchronized (Singleton.class) {  
		        if (instance == null) {  
		            instance = new Singleton();  
		        }  
	        }  
	    }  
    	return instance;  
    }  
}
```


# 3 备忘录模式
## 简介
1. 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态；
2. 应用场景：Windows 里的 ctrl + z ，PS里的快照；

## 实现
### 1 创建Memento（备忘录）类

Memento.java

```java
public class Memento {
   private String state;
 
   public Memento(String state){
      this.state = state;
   }
 
   public String getState(){
      return state;
   }  
}
```

### 2 创建Originator（发起者） 类

Originator.java

```java
public class Originator {
   private String state;
 
   public void setState(String state){
      this.state = state;
   }
 
   public String getState(){
      return state;
   }
 
   public Memento saveStateToMemento(){
      return new Memento(state);
   }
 
   public void getStateFromMemento(Memento Memento){
      state = Memento.getState();
   }
}
```

### 3 创建 CareTaker（管理员） 类

CareTaker.java

```java
public class CareTaker {
   private List<Memento> mementoList = new ArrayList<Memento>();
 
   public void add(Memento state){
      mementoList.add(state);
   }
 
   public Memento get(int index){
      return mementoList.get(index);
   }
}
```
### 4 使用Originator（发起者） 和CareTaker（管理员） 对象

MementoPatternDemo.java

```java
public class MementoPatternDemo {
   public static void main(String[] args) {
      Originator originator = new Originator();
      CareTaker careTaker = new CareTaker();
      originator.setState("State #1");
      originator.setState("State #2");
      careTaker.add(originator.saveStateToMemento());
      originator.setState("State #3");
      careTaker.add(originator.saveStateToMemento());
      originator.setState("State #4");
 
      System.out.println("Current State: " + originator.getState());    
      originator.getStateFromMemento(careTaker.get(0));
      System.out.println("First saved State: " + originator.getState());
      originator.getStateFromMemento(careTaker.get(1));
      System.out.println("Second saved State: " + originator.getState());
   }
}
```

```java
Current State: State #4
First saved State: State #2
Second saved State: State #3
```

# 4 MVC模式（未完，待续）
## 简介
1. 即Model-View-Controller（模型-视图-控制器） 模式，这种模式用于应用程序的分层开发；
2. Model（模型）：代表一个存取数据的对象或JAVA POJO；
3. View（视图）：代表模型包含的数据的可视化；
4. Controller（控制器）：作用于模型和视图上，它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开；
5. 应用场景：1 Web 项目的开发中，用户在网页上单击一个 URL 路径，这对 Web 服务器来说，相当于用户发送了一个请求。而获取请求后如何解析用户的输入，并执行相关处理逻辑，最终跳转至正确的页面显示反馈结果，这些工作往往是控制层（Controller）来完成的；2 在请求的过程中，用户的信息被封装在 User 实体类中，该实体类在 Web 项目中属于数据模型层（Model）；3 在请求显示阶段，跳转的结果网页就属于视图层（View）；4 像这样，控制层负责前台与后台的交互，数据模型层封装用户的输入/输出数据，视图层选择恰当的视图来显示最终的执行结果，这样的层次分明的软件开发和处理流程被称为 MVC 模式；5 在学习 Servlet 及 JSP 开发时，JavaBean 相当于 Model，Servlet 相当于 Controller，JSP 相当于 View；

## 实现
Student作为模型类；StudentView作为视图类，把学生详细信息输出到控制台；StudentController作为控制器类，负责控制数据流向Student对象，并相应地更新视图。

### 1 创建Model（模型）

Student.java

```java
public class Student {
   private String rollNo;
   private String name;
   public String getRollNo() {
      return rollNo;
   }
   public void setRollNo(String rollNo) {
      this.rollNo = rollNo;
   }
   public String getName() {
      return name;
   }
   public void setName(String name) {
      this.name = name;
   }
}
```

### 2 创建View（视图）

StudentView.java

```java
public class StudentView {
   public void printStudentDetails(String studentName, String studentRollNo){
      System.out.println("Student: ");
      System.out.println("Name: " + studentName);
      System.out.println("Roll No: " + studentRollNo);
   }
}
```

### 3 创建Controller（控制器）

StudentController.java

```java
public class StudentController {
   private Student model;
   private StudentView view;
 
   public StudentController(Student model, StudentView view){
      this.model = model;
      this.view = view;
   }
 
   public void setStudentName(String name){
      model.setName(name);    
   }
 
   public String getStudentName(){
      return model.getName();    
   }
 
   public void setStudentRollNo(String rollNo){
      model.setRollNo(rollNo);      
   }
 
   public String getStudentRollNo(){
      return model.getRollNo();     
   }
 
   public void updateView(){           
      view.printStudentDetails(model.getName(), model.getRollNo());
   }  
}
```
### 4 使用 Controller 中的方法

MVCPatternDemo.java

```java
public class MVCPatternDemo {
   public static void main(String[] args) {
 
      //从数据库获取学生记录
      Student model  = retrieveStudentFromDatabase();
 
      //创建一个视图：把学生详细信息输出到控制台
      StudentView view = new StudentView();
 
      StudentController controller = new StudentController(model, view);
 
      controller.updateView();
 
      //更新模型数据
      controller.setStudentName("John");
 
      controller.updateView();
   }
 
   private static Student retrieveStudentFromDatabase(){
      Student student = new Student();
      student.setName("Robert");
      student.setRollNo("10");
      return student;
   }
}
```

```java
Student: 
Name: Robert
Roll No: 10
Student: 
Name: John
Roll No: 10
```

